# WebAssembly Integration in Tauri/SolidJS/Vite

This document outlines our approach to integrating WebAssembly (WASM) with our Tauri/SolidJS/Vite stack, specifically for the canvas performance test harness.

## Architecture Overview

Our application uses WebAssembly to offload performance-critical canvas object management to Rust, while handling rendering in JavaScript with PixiJS v8. This architecture enables high-performance canvas applications similar to Figma or comic creation tools.

```ascii
+----------------------+      +----------------------+
|                      |      |                      |
|  JS/TS Frontend      |      |  Rust WASM           |
|  (SolidJS + PixiJS)  | <--> |  Canvas Object       |
|  Rendering Layer     |      |  Management          |
|  & User Interaction  |      |  & Transformations   |
|                      |      |                      |
+----------------------+      +----------------------+
```

## Implementation Details

### WASM Module Building

1. The Rust code is located in `src-tauri/canvas_sim/`
2. It is compiled to WebAssembly using wasm-bindgen
3. The compiled artifacts are directly imported from the package directory:
   - `canvas_sim_bg.wasm` - The actual WebAssembly binary
   - JavaScript glue code generated by wasm-bindgen

### Vite Configuration

To properly handle WebAssembly in Vite, we use two plugins:

- `vite-plugin-wasm` - Enables WebAssembly ESM integration in Vite
- `vite-plugin-top-level-await` - Handles top-level await commonly used in WASM initialization

Configuration in `vite.config.ts`:

```typescript
import { defineConfig } from 'vite';
import solidPlugin from 'vite-plugin-solid';
import wasm from 'vite-plugin-wasm';
import topLevelAwait from 'vite-plugin-top-level-await';

export default defineConfig({
  plugins: [
    solidPlugin(),
    wasm(),
    topLevelAwait()
  ],
  // Other config options...
  build: {
    target: 'esnext',
  },
});
```

### TypeScript Integration

TypeScript doesn't inherently understand WASM imports, so we've added type declarations in `src/types/wasm-modules.d.ts` to help the TypeScript compiler understand our WASM imports.

### WASM Loading Strategy

Our `CanvasTestHarness` class handles the dynamic loading of the WASM module:

1. We import the WASM module using ESM imports (handled by Vite plugins)
2. We initialize the WASM module and create a canvas simulation instance
3. We handle asynchronous initialization with proper error handling
4. We log initialization status using Tauri logging for traceability
5. We separate concerns between WASM object management and PixiJS rendering

### Key Components

- `CanvasTestHarness.ts` - Main integration point between PixiJS and WASM
- `src-tauri/canvas_sim/src/lib.rs` - Rust implementation of canvas object management
- `CanvasPerformanceTest.tsx` - SolidJS component for test harness UI and controls

## Best Practices

1. **Asynchronous Initialization**: Always await WASM module initialization before using it
2. **Error Handling**: Robust error handling for WASM loading failures
3. **Resource Cleanup**: Free WASM resources in the destroy method
4. **Type Safety**: TypeScript declarations to ensure type safety with WASM imports

## Usage Example

```typescript
// Create the canvas test harness
const testHarness = new CanvasTestHarness(containerElement);

// Initialize the harness with PixiJS and WASM
await testHarness.initialize();

// Create canvas objects for testing
await testHarness.setObjectCount(1000); // 1,000 objects

// Set test mode (static, rotating, scaling, interactive, stress)
await testHarness.setTestMode('rotating');

// Performance monitoring
const metrics = testHarness.getPerformanceMetrics();
// metrics.fps, metrics.renderTime, metrics.objectCount, metrics.memoryUsage

// The render loop is automatically started in the harness

// Cleanup when done
testHarness.cleanup();
```
